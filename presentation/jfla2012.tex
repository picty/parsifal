\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[french]{babel}
\usepackage{array}
\usepackage{listings}
\lstset{language=Caml, basicstyle=\footnotesize,
  morekeywords={enum, alias, struct, union,
                asn1_struct, asn1_alias,
                UnknownVal, with_lwt, Exception}}
\usepackage{xspace}
 
\usepackage{xcolor}
\newcommand{\TODO}[1]{\textcolor{red}{#1}}

\newcommand{\FAceSL}{\TODO{FAceSL}\xspace}
\newcommand{\FAceSLTypes}{\TODO{FAceSLTypes}\xspace}
\newcommand{\FAceSLType}{\TODO{FAceSLType}\xspace}

\title{Utilisation de \texttt{camlp4} pour l'écriture rapide de \emph{parsers}}
\author{Olivier Levillain}

\begin{document}

\maketitle

Dans le cadre de ses activités d'expertise, le laboratoire sécurité
des réseaux et protocoles (LRP) de l'agence nationale de la sécurité
des systèmes d'information (ANSSI) est amené à étudier divers
protocoles de communication. L'étude fine de ces protocoles passe par
l'utilisation de \emph{parsers} (dissecteurs) de confiance permettant
d'analyser les messages échangés lors d'une instance du protocole.

L'expérience a montré qu'il était souvent utile (voire nécessaire) de
disposer d'implémentations indépendantes et robustes pour étudier et
comprendre les comportements d'un protocole donné, en particulier pour
détecter et caractériser les messages incorrects. En effet, les
implémentations disponibles de clients, serveurs ou dissecteurs sont
parfois limitées (refus de certaines options), laxistes (accetation
silencieuse de paramètres erronés) ou fragile (terminaison brutale du
programme pour des valeurs inattendues, qu'elles soient licites ou
non).

Ce constat a donc conduit au développement de certains outils par les
membres du laboratoire. L'objectif était de développer
\emph{rapidement} des dissecteurs \emph{robustes} et
\emph{efficaces}. Pour cela, plusieurs langages de programmation ont
été testés (C++, python, OCaml). L'objet de ce document est de
présenter l'une de ces implémentations, reposant sur le pré-processeur
\texttt{camlp4} d'OCaml.



\section{Contexte}

Le point de départ de ces travaux était l'analyse d'une quantité
importante de données récoltées concernant le protocole TLS. Ces
données proviennent de résultats mis à dispositions par l'Electronic
Frontier Foundation (EFF) et de collectes effectuées par Télécom
SudParis et l'ANSSI. Les traces analysées contiennent une très grande
diversité de réponses, et certaines sont incohérentes ou non conformes
au protocole TLS.

Face à cet imposant corpus, il était difficile d'utiliser des outils
existants pour extraire de manière fiable l'information pertinente
pour les analyses. Dans le cas de TLS, l'objectif était d'effectuer un
état des lieux de la qualité des serveurs TLS dans le monde, et son
évolution dans le temps. Ces travaux ont fait l'objet d'une
publication à venir à ACSAC~\cite{ACSAC2012}.

Le premier \emph{parser} pour cette tâche a été écrit en Python,
permettant d'obtenir rapidement un prototype pour extraire les
premiers éléments des données. Cependant, ce premier programme s'est
révélé trop lent face au volume de données à traiter. Une seconde
implémentation a donc vu le jour, en C++. Celle-ci reposait sur les
\emph{templates} et la programmation objet, et permettait d'obtenir un
dissecteur flexible et efficace, mais au prix d'une grande quantité de
code à écrire et d'erreurs de programmation pas toujours évidentes à
diagnostiquer (fuites mémoire, erreurs de segmentation).

Pour pallier ce manque de robustesse, une troisième version des outils
a été entreprise, en OCaml. Afin de conserver la flexibilité imaginée
pour le second prototype, un langage spécifique a été développé pour
décrire les structures à disséquer. Les outils résultants étaient
expressifs, efficaces et plus fiables que la version
précédente. Pourtant, l'extensibilité de cette implémentation
nécessitait encore une lourdeur dans l'écriture du code qui s'est
révélée assez fastidieuse à l'usage.

Finalement, une nouvelle implémentation en OCaml a été réalisée pour
tenter de réunir l'ensemble des qualités recherchées pour le
développement de \emph{parsers}:
\begin{itemize}
\item rapidité d'écriture;
\item garanties fortes sur le fonctionnement des outils;
\item efficacité des programmes produits.
\end{itemize}
Cette quatrième mouture, \FAceSL, résulte de la fusion entre le
langage spécifique de description des objets analysés et le langage de
programmation. Pour cela, le processeur \texttt{camlp4} a été employé
pour la génération automatique des types et des fonctions à partir de
descriptions brèves des structures à disséquer.



\section{Présentation de \FAceSL}


\subsection{Un premier exempe: le format TAR}

L'en-tête du format TAR est décrit dans le
tableau~\ref{tab:tar-format}, et décrit deux versions du format: le
format original (colonne TAR) et une variante plus récente (colonne
\texttt{ustar}). Pour des raisons de compatibilité, les valeurs
numériques sont systématiquement stockées sous la forme d'une chaîne
de caractère représentant la valeur numérique en octal\footnote{Cette
  méthode permet d'éviter de tomber dans les pièges de
  l'\emph{endianness} par exemple, mais au prix d'une plus grande
  consommation mémoire.}. L'en-tête est contenu dans un «~bloc~» de
512~octets, et le contenu du fichier qui suit l'en-tête est complété
par des caractères nuls pour former des blocs de 512~octets.

\begin{table}
  \begin{center}
    \begin{tabular}{|r|r|l|l|}
      \hline
      \multicolumn{1}{|c|}{\bf Offset} &
      \multicolumn{1}{c|}{\bf Long.} &
      \multicolumn{2}{c|}{\bf Description} \\
      & & \multicolumn{1}{c|}{\bf TAR} &
      \multicolumn{1}{c|}{\bf \tt ustar} \\
      \hline

      \hline
        0 & 100 & \multicolumn{2}{l|}{Nom du fichier} \\
      \hline
      100 &   8 & \multicolumn{2}{l|}{Permissions} \\
      \hline
      108 &   8 & \multicolumn{2}{l|}{UID} \\
      \hline
      116 &   8 & \multicolumn{2}{l|}{GID} \\
      \hline
      124 &  12 & \multicolumn{2}{l|}{Taille du fichier} \\
      \hline
      136 &  12 & \multicolumn{2}{l|}{\emph{Timestamp} de la dernière modification} \\
      \hline
      148 &   8 & \multicolumn{2}{l|}{Somme de contrôle de l'en-tête} \\
      \hline
      156 &   1 & Indicateur de lien & Type de fichier \\
      \hline
      157 & 100 & \multicolumn{2}{l|}{Nom du fichier pointé par le lien} \\
      \hline
      257 &   6	& \multicolumn{1}{c|}{-} & Indicateur \texttt{"ustar"} \\
      \hline
      263 &   2	& \multicolumn{1}{c|}{-} & Version UStar ("00") \\
      \hline
      265 &  32 & \multicolumn{1}{c|}{-} & Propriétaire \\
      \hline
      297 &  32 & \multicolumn{1}{c|}{-} & Groupe propriétaire \\
      \hline
      329 &   8 & \multicolumn{1}{c|}{-} & Numéro majeur du périphérique \\
      \hline
      337 &   8 & \multicolumn{1}{c|}{-} & Numéro mineur du périphérique \\
      \hline
      345 & 155 & \multicolumn{1}{c|}{-} & Préfixe \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Description de l'en-tête TAR.}
  \label{tab:tar-format}
\end{table}

Le champ à l'offset~156 décrit le type de fichier, et a été étendu par
\texttt{ustar}. La table \ref{tab:tar-filetypes} récapitule les
différentes valeurs qu'il peut prendre.

\begin{table}
  \begin{center}
    \begin{tabular}{|>{\tt}c|l|c|}
      \hline
      \multicolumn{1}{|c|}{\bf Caractère} &
      \multicolumn{1}{c|}{\bf Description} &
      \multicolumn{1}{c|}{\bf \tt ustar} \\
      \hline

      \hline
      <NUL>, 0 & fichier ordinaire & - \\
      1 & lien dur & - \\
      2 & lien symbolique & - \\
      \hline
      3 & périphérique en mode caractères & oui \\
      4 & périphérique en mode blocs & oui \\
      5 & répertoire & oui \\
      6 & file FIFO & oui \\
      7 & fichier contigu & oui \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Valeurs du champ «~Indicateur de lien/Type de fichier~».
    La colonne \texttt{ustar} indique si la valeur est spécifique à
    la version étendue du format.}
  \label{tab:tar-filetypes}
\end{table}


Afin d'utiliser notre préprocesseur pour décrire les fichiers au
format TAR, commençons par décrire les valeurs du champ «~Indicateur
de lien/Type de fichier~». Il s'agit d'une énumération sur 8~bits,
dont nous connaissons certaines valeurs qui s'écrit avec le nouveau
mot-clé \texttt{enum}. Si l'analyseur généré rencontre un type
inconnu, il est possible d'utiliser un constructeur spécifique ou de
lever une exception. Nous avons choisi le premier cas, avec le
constructeur spécifique \texttt{UnknownFileType}:
\begin{lstlisting}
enum file_type (8, UnknownVal UnknownFileType, []) =
  | 0 -> NormalFile
  | 0x30 -> NormalFile
  | 0x31 -> HardLink
  | 0x32 -> SymbolicLink
  | 0x33 -> CharacterSpecial
  | 0x34 -> BlockSpecial
  | 0x35 -> Directory
  | 0x36 -> FIFO
  | 0x37 -> ContiguousFile
\end{lstlisting}

Ensuite, on peut décrire l'enregistrement contenant les différents
champs constituant d'un en-tête à l'aide du mot clé \texttt{struct},
qui ressemble à la description d'un enregistrement Caml, mais qui
accepte des types enrichis nommés \FAceSLTypes:
\begin{lstlisting}
struct tar_header = {
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
  hdr_padding : binstring(12);
}

struct tar_entry = {
  header : tar_header;
  file_content : binstring(header.file_size);
  file_padding : binstring(512 - (header.file_size % 512))
}

alias tar_file = list of tar_entry;
\end{lstlisting}

Le code resultant du préprocesseur permet alors d'ouvrir une archive
simplement à l'aide de la fonction \texttt{parse\_tar\_file}, qui
prend en entier la chaîne de caractères correspondant au contenu du
fichier. Afin de traiter des données importantes de manière efficace,
il est également possible de produire une version du \emph{parser} en
mode flux, qui repose sur la bibliothèque \texttt{lwt}. Pour cela, il
suffit de redéfinir l'alias en lui adjoignant la et d'utiliser cette
fois la fonction \texttt{lwt\_parse\_tar\_file}:
\begin{lstlisting}
alias tar_file [with_lwt] = list of tar_entry;

let handle_filename filename =
  Lwt_unix.openfile filename [Unix.O_RDONLY] 0 >>= fun fd
  lwt_parse_tar_file (input_of_fd filename fd) >>= fun tar_file
  let print_filename entry = print_string entry.file_name in
  List.iter print_filename tar_file;
  return ()

let _ =
  Lwt_unix.run (handle_filename "test.tar");
\end{lstlisting}


\subsection{Pour aller plus loin}

La première version proposée est fonctionnelle, mais si l'on souhaite
proprement prendre en compte les vieilles archives, ne contenant pas
l'en-tête étendu commençant par le marqueur \texttt{ustar}, on peut
réécrire la description de l'en-tête de la manière suivante, en
éclatant l'en-tête en deux morceaux, dont un optionnel.
\begin{lstlisting}
struct ustar_header = {
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
}

struct tar_header = {
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  optional ustar_header : ustar_header;
  hdr_padding : binstring;
}

struct tar_entry = {
  header : container(512) of tar_header;
  file_content : binstring(header.file_size);
  file_padding : binstring(512 - (header.file_size % 512))
  checksum_verification : check of check_crc32 (header,
                                    file_content, file_padding);
}

alias tar_file = list of tar_entry;
\end{lstlisting}

Avec cette seconde version, on utilise un conteneur de 512 octets pour
lire l'en-tête. Si l'en-tête est étendu, le champ
\texttt{ustar\_header} sera peuplé et le champ \texttt{hdr\_padding},
une chaîne binaire consommant les octets restants du conteneur,
contiendra~12~octets; dans le cas contraire, la fonction
\texttt{parse\_ustar\_header} échouera, le champ
\texttt{ustar\_header} vaudra \texttt{None} et \texttt{hdr\_padding}
aura une longueur de 255~octets.

Le lecteur attentif aura également remarqué l'ajout d'un champ intitulé
\texttt{checksum\_verification}, qui permet d'exécuter une
vérification de la somme de contrôle une fois l'entrée TAR entièrement
disséquée. Cette ligne ne produit pas de champ dans le type OCaml
\texttt{tar\_entry} généré, mais appelle la fonction
\texttt{check\_crc32} (à écrire) sur les champs déjà disséqués. On
pourrait utiliser ce type de champs pour vérifier d'autres propriétés
(le champ \texttt{hdr\_padding} est par exemple censé ne contenir que
des caractères nuls).

Le format TAR faisant un usage important des chaînes de caractères
encodant une valeur numérique, on pourrait aussi créer de toute pièce
un nouveau type, \texttt{tar\_numstring}, de la manière
suivante\footnote{Pour des raisons historiques, un champ de 8~octets
  sera terminé par un espace ou un caractère nul, ne laissant ainsi en
  pratique que 7~octets pour encoder la valeur.}:
\begin{lstlisting}
type tar_numstring = int * int

let parse_tar_numstring len input =
  let octal_value = parse_string (len - 1) input in
  drop_bytes 1 input;
  int_of_string ("0o" ^ octal_value)

let dump_tar_numstring len v =
  Printf.printf "%*.*o\x00" len len v

let print_tar_numstring ?indent:(indent="")
                        ?name:(name="numstring") v =
  Printf.sprintf "%s%s: %d (%o)\n" indent name v v
\end{lstlisting}

On peut alors modifier les champs représentant des valeurs numériques
en octal en replaçant le type \texttt{string(n)} par
\texttt{tar\_numstring(n)}. L'expressivité de \FAceSL peut ainsi être
étendue facilement à l'aide de \FAceSLTypes personnalisés.



\section{Description des extensions du langage}


\subsection{\'Enumérations}

\shorthandoff{:}
\begin{tabbing}
  \textit{énumération} ::= \textbf{\tt enum} \= \textit{identifiant} (\textit{taille}, \textit{comportement}, \textit{enum\_options}) = \\
  \> $\vert$ \textit{pattern} $\rightarrow$ \textit{Constructeur} [, \textit{texte}\footnote{Ce
    texte sera renvoyé par \texttt{string\_of\_enum} pour cette valeur de l'énumération.
    Si aucun texte n'est donné, le nom du constructeur sera utilisé.}] \\
  \> ... \\
  \> $\vert$ \textit{pattern} $\rightarrow$ \textit{Constructeur} [, \textit{texte}] \\
  \\
  \textit{comportement} ::\= = \= \textbf{\tt UnknownVal} \textit{Constructor} \\
  \> $\vert$ \> \textbf{\tt Exception} \textit{Exception} \\
  \\
  \textit{enum\_option} \= ::= \textbf{\tt with\_lwt} \\
\end{tabbing}
\shorthandon{:}

Une déclaration d'énumération \texttt{enum} est alors transformée en
une déclaration de type OCaml et un ensemble de fonctions. Par
exemple, la déclaration suivante:
\begin{lstlisting}
enum tls_version (16, UnknownVal V_Unknown, [with_lwt]) =
  | 0x0002 -> V_SSLv2, "SSLv2"
  | 0x0300 -> V_SSLv3, "SSLv3"
  | 0x0301 -> V_TLSv1, "TLSv1.0"
  | 0x0302 -> V_TLSv1_1, "TLSv1.1"
  | 0x0303 -> V_TLSv1_2, "TLSv1.2"
\end{lstlisting}

\noindent génère le type somme suivant:
\begin{lstlisting}
type tls_version =
  | V_SSLv2 | V_SSLv3 | V_TLSv1 | V_TLSv1_1 | V_TLSv1_2
  | V_Unknown of int
\end{lstlisting}

\noindent et les fonctions suivantes:
\begin{lstlisting}
val string_of_tls_version : tls_version -> string
val int_of_tls_version : tls_version -> int
val tls_version_of_int : int -> tls_version
val tls_version_of_string : string -> tls_version

val parse_tls_version : string_input -> tls_version
val lwt_parse_tls_version : lwt_input -> tls_version
val dump_tls_version : tls_version -> string
val print_tls_version : ?indent:string -> ?name:string ->
                        tls_version -> string
\end{lstlisting}

Les quatre premières fonctions générées permettent simplement de
convertir le type énumération depuis et vers les entiers et les
chaînes de caractères. Le \textit{comportement} de la grammaire
ci-dessus indique comment \texttt{tls\_version\_of\_int} doit traiter
une valeur non fournie dans l'énumération: ici, \texttt{UnknownVal
  V\_Unknown} indique qu'il faut renvoyer une valeur
\texttt{V\_Unknown i} où \texttt{i} est la valeur non
reconnue. L'autre comportement possible est de lever une exception.

Les quatre fonctions suivantes fournissent des services de plus haut
niveau: \emph{parser} l'énumération depuis une chaîne de caractères
(\texttt{parse}) ou un flux \texttt{Lwt} (\texttt{lwt\_parse}),
exporter une structure au format binaire (\texttt{dump}) ou en obtenir
une version affichable (\texttt{print}). Cette dernière fonction
accepte des options pour modifier l'indentation et le nom de la
structure à afficher.


\subsection{\FAceSLTypes}

\shorthandoff{:}
\begin{tabbing}
  \textit{\FAceSLType} ::\= = \= \texttt{char} \\
  \> $\vert$ \> \textbf{\tt uintN} \\
  \> $\vert$ \> \textbf{\tt ipv4} \\
  \> $\vert$ \> \textbf{\tt ipv6} \\
  \> $\vert$ \> \textbf{\tt string} \\
  \> $\vert$ \> \textbf{\tt string} (\textit{expression}) \\
  \> $\vert$ \> \textbf{\tt string} [\textit{type entier}] \\
  \> $\vert$ \> \textbf{\tt list} of \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textit{custom type} \\
  \> $\vert$ \> \textit{custom type} (\textit{paramètres}) \\
\end{tabbing}
\shorthandon{:}

Parler de binstring, de la logique de (), [] et du fonctionnement de
custom et des paramètres.


\subsection{Structures}

\shorthandoff{:}
\begin{tabbing}
  \textit{structure} ::= \= \textbf{\tt struct} \= \textit{identifiant} [\textit{struct\_options}] = \{ \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType}; \\
  \> \> ... \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType} \\
  \> \} \\
  \\
  \textit{struct\_option} ::\= = \= \textbf{\tt with\_lwt} \\
  \> $\vert$ \> \textbf{\tt with\_exact} \\
  \> $\vert$ \> \textbf{\tt top} \\
  \> $\vert$ \> \textbf{\tt param} \textit{expression} \\
\end{tabbing}
\shorthandon{:}

Exemple de structure et des fonctions générées.

top = with\_lwt + with\_exact

param permet d'ajouter des paramètres aux fonctions parse et dump

\subsection{Unions}

\shorthandoff{:}
\begin{tabbing}
  \textit{union} ::= \textbf{\tt union} \= \textit{identifiant} (\textit{comportement}, \textit{union\_options}) = \\
  \> $\vert$ \textit{pattern} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \> ... \\
  \> $\vert$ \textit{pattern} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \\
  \textit{comportement} ::\= = \= \textit{Constructor} \\
  \> $\vert$ \> \textit{Constructor} of \textit{\FAceSLType} \\
  \\
  \textit{struct\_option} ::\= = \= \textbf{\tt with\_lwt} \\
  \> $\vert$ \> \textbf{\tt with\_exact} \\
  \> $\vert$ \> \textbf{\tt top} \\
  \> $\vert$ \> \textbf{\tt enrich} \\
  \> $\vert$ \> \textbf{\tt exhaustive} \\
  \> $\vert$ \> \textbf{\tt param} \textit{expression} \\
\end{tabbing}
\shorthandon{:}

Exemple d'union

parse/lwt\_parse prend systématiquement un argument en plus. Ce dernier
argument est le discriminant, qui va être comparé aux différents
motifs proposés dans la description de l'union. Si l'option
\texttt{exhaustive} est positionnée, ce \emph{pattern matching} devra
être exhaustif. Si l'option \texttt{enrich} est positionnée, le
\emph{parser} généré tentera d'enrichir l'union par défaut; sinon, il
construira systématiquement des unions non enrichies (en utilisant le
constructeur du comportement donné)

top, lwt, exact et param ont le même sens qu'avant.


\subsection{Alias}

\shorthandoff{:}
\begin{tabbing}
  \textit{alias} ::= \textbf{\tt alias} \textit{identifiant} = \textit{\FAceSLType} \\
\end{tabbing}
\shorthandon{:}

Exemple d'alias

\subsection{Types ASN.1}


\subsection{Structures ASN.1}


\subsection{Alias ASN.1}



\section{Quelques mots sur l'implémentation \texttt{camlp4}}


\subsection{Des chiffres}

Nb de lignes

Disponibilité du package


\subsection{Anecdotes}

Difficulté à écrire du camlp4 car peu de documentation, mais une fois
les types compris, la manipulation de l'AST est extrêmement riche.

Comportement surprenant: camlp4o <preprocessors> <fichier.ml> a un
comportement différent selon que la sortie standard est un pipe ou une
console...



\section{Applications}


\subsection{TLS et X.509}

Le point de départ de ces travaux sur les \emph{parsers} était
l'analyse de données TLS~\cite{rfc5246} contenant des certificats
X.509~\cite{rfc5280} (structures ASN.1 encodées au format DER). Il
s'agit donc logiquement de la première application concrète de
\FAceSL.

nombre de lignes de code (nb pour les descriptions, nb pour la glu),
quelques exemples de types (struct, etc.), efficacité, description des
outils.


\subsection{MRT}

BGP est l'un des protocoles étudiés dans le laboratoire sécurité des
réseaux et protocoles. Le format d'échange utilisé pour archiver et
transmettre l'ensemble des annonces vues par une sonde est
\emph{Multi-Threaded Routing Toolkit} (MRT)~\cite{rfc6396}.

Là encore, deux outils étaient utilisés pour analyser une grande
quantité de données au format MRT, le premier en C\footnote{Il est à
  noter que cet outil en C se terminait parfois de manière brutale sur
  certains fichiers sans aucune explication}, le second en OCaml. Il a
suffi de 4 jours pour décrire en \FAceSL les structures MRT
pertinentes pour les études menées au laboratoire et obtenir un outil
indépendant des deux autres, plus rapide que l'implémentation en OCaml
pré-existante et plus fiable que l'implémentation en C.

nb de lignes de code, tableau de comparaison de l'efficacité


\subsection{Troisième application?}



\section{Related work et perspectives}

Les extensions du langage écrites en \texttt{camlp4} ressemblent à scapy / hachoir ?

Intérêt de la solution retenue : peu de lignes, très expressif, robuste (typage), efficace!

Impact d'OCaml 4 ?

Autres parsers: DNS, pcap, etc.



\bibliographystyle{plain}
\bibliography{biblio,rfc}


\end{document}