\documentclass[twoside]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes}
\usepackage[french]{babel}

\usepackage{url}
\usepackage{array}
\usepackage{listings}
\lstset{language=Caml, basicstyle=\footnotesize,
  morekeywords={enum, alias, struct, union,
                asn1_struct, asn1_alias,
                UnknownVal, with_lwt, Exception}}
\usepackage{xspace}
\newcommand{\FAceSL}{Parsifal\xspace}
\newcommand{\FAceSLTypes}{PTypes\xspace}
\newcommand{\FAceSLType}{PType\xspace}

\title{Utilisation de \texttt{camlp4} pour l'écriture rapide de \emph{parsers}}
\author{Olivier Levillain$^{1,2}$}
\titlehead{Écriture rapide de \emph{parsers} en \texttt{camlp4}}
\authorhead{O. Levillain}
\affiliation{\begin{tabular}{rr} 
      \\ 1:  Agence nationale de la sécurité des systèmes d'information (ANSSI)
      \\     51 boulevard Latour Maubourg, 75700 Paris 07 SP
      \\     {\tt olivier.levillain@ssi.gouv.fr} 
      \\ 2:  Télécom Sud Paris
      \\     9 rue Charles Fourier, 91011 Evry
    \end{tabular}
}


\begin{document}

\setcounter{page}{1}
\maketitle

Dans le cadre de ses activités d'expertise, le laboratoire sécurité
des réseaux et protocoles (LRP) de l'agence nationale de la sécurité
des systèmes d'information (ANSSI) est amené à étudier divers
protocoles de communication. L'étude fine de ces protocoles passe par
l'utilisation de \emph{parsers} (dissecteurs) de confiance permettant
d'analyser les messages échangés lors d'une instance du protocole.

L'expérience a montré qu'il était souvent utile (voire nécessaire) de
disposer d'implémentations in\-dé\-pen\-dant\-es et robustes pour étudier et
comprendre les comportements d'un protocole donné, en particulier pour
détecter et caractériser les messages incorrects. En effet, les
implémentations disponibles de clients, serveurs ou dissecteurs sont
parfois limitées (refus de certaines options), laxistes (acceptation
silencieuse de paramètres erronés) ou fragiles (terminaison brutale du
programme pour des valeurs inattendues, qu'elles soient licites ou
non).

Ce constat a donc conduit au développement de certains outils par les
membres du laboratoire. L'objectif était de développer
\emph{rapidement} des dissecteurs \emph{robustes} et
\emph{efficaces}. Pour cela, plusieurs langages de programmation ont
été testés (C++, python, OCaml). L'objet de ce document est de
présenter l'une de ces implémentations, reposant sur le pré-processeur
\texttt{camlp4} d'OCaml. La section~\ref{sec:historique} présente
l'historique du projet et deux applications fonctionnelles concernant
TLS et BGP. La section~\ref{sec:tar} présente un exemple complet
d'utilisation de \FAceSL, le format d'archive TAR. Enfin, la
section~\ref{sec:description} donne un aperçu de l'ensemble des
constructions apportées par \FAceSL (la grammaire exacte est donnée en
annexe).



\section{Historique du projet}
\label{sec:historique}


\subsection{Motivation initiale: analyser de nombreuses réponses TLS}

Le point de départ de ces travaux était l'analyse d'une quantité
importante de données récoltées concernant le protocole SSL/TLS. SSL
(\emph{Secure Sockets Layer}) et TLS (\emph{Transport Layer Security})
sont deux variantes d'un même protocole, dont la dernière version est
TLSv1.2~\cite{rfc5246}. Leur objectif est de fournir un certain nombre
de services pour sécuriser un canal de communication:
\begin{itemize}
\item authentification unilatérale ou mutuelle;
\item confidentialité des données échangées de bout en bout;
\item intégrité des données de bout en bout.
\end{itemize}

SSL a initalement été mis au point par Netscape pour protéger les
connexions HTTP. Le résultat de cette association (HTTP~+~SSL) est
désigné par l'acronyme HTTPS. Même si SSL/TLS peut être utilisé pour
sécuriser d'autres protocoles applicatifs, HTTPS reste l'application
principale de la couche cryptographique SSL/TLS. C'est la raison pour
laquelle plusieurs équipes de recherche ont récemment entrepris des
collectes sur l'ensemble des serveurs HTTPS accessibles sur internet,
afin d'évaluer la qualité des réponses TLS apportées par tous ces
serveurs.

Afin de pouvoir interpréter correctement les différents types de
réponses, il est nécessaire de comprendre les différentes versions du
protocole (SSLv2, SSLv3, TLSv1.0, TLSv1.1 et TLSv1.2), qui apportent
chacune des subtilités dans les messages échangés. Parmi les messages
pertinents pour ce type d'étude, le message \texttt{Certificate}
contient la chaîne de certification permettant l'authentification du
serveur. Elle contient des certificats X.509~\cite{rfc5280}, dont le
format repose sur l'ASN.1, une syntaxe pour encoder de manière
structurée des entiers, des chaînes de caractères ou encore des objets
binaires\footnote{Plus précisément, l'ASN.1 (\emph{Abstract Syntax
    Notation One}) permet de décrire de manière abstraite la structure
  d'un certificat X.509; l'encodage utilisé pour les certificat et le
  DER (\emph{Distinguished Encoding Rules}), une représentation
  concrète canonique de l'ASN.1.}, ce qui apporte une complexité
supplémentaire pour la dissection des messages.

Le LRP a mené des travaux sur de nombreuses traces HTTPS depuis deux
ans. Les données utilisées proviennent de résultats mis à dispositions
par l'Electronic Frontier Foundation~\cite{eff-observatory,
  eckersley-obs1, eckersley-obs2} en 2010 et de collectes effectuées
par Télécom SudParis et l'ANSSI en 2011. Les traces analysées
contiennent une très grande diversité de réponses, et certaines sont
incohérentes ou non conformes au protocole TLS. Face à cet imposant
corpus, il était difficile d'utiliser des outils existants pour
extraire de manière fiable l'information pertinente pour les
analyses. En effet, les implémentations existantes ont généralement un
comportement inadapté à l'analyse, qu'il s'agisse d'un comportement
limité (refus de certaines options), laxiste (acceptation silencieuse
de paramètres erronés) ou fragiles (terminaison brutale du programme
pour des valeurs inattendues, qu'elles soient licites ou non).

Des outils spécifiques, maîtrisés par le laboratoire, ont donc été
développés pour analyser ce grand volume de données (180~Go).


\subsection{Démarche de développement des outils}

Le premier \emph{parser} réalisé pour cette tâche a été écrit en
Python. Nous avons ainsi obtenu rapidement un prototype pour extraire
les premiers éléments des données. Cependant, ce premier programme
s'est révélé trop lent face au volume à traiter.

Une seconde implémentation a donc vu le jour, en C++. Celle-ci
reposait sur les \emph{templates} et la programmation objet, et
permettait d'obtenir un dissecteur flexible et efficace, mais au prix
d'une grande quantité de code à écrire et d'erreurs de programmation
pas toujours évidentes à diagnostiquer (fuites mémoire, erreurs de
segmentation).

Pour pallier ce manque de robustesse, le développement d'une troisième
version des outils a été entreprise, en OCaml. Afin de conserver la
flexibilité imaginée pour le second prototype, un langage spécifique a
été développé pour décrire les structures à disséquer. Les outils
résultants étaient expressifs, efficaces et plus fiables que la
version précédente. Pourtant, l'extensibilité de cette implémentation
nécessitait encore une lourdeur dans l'écriture du code qui s'est
révélée assez fastidieuse à l'usage.

Finalement, une nouvelle implémentation en OCaml a été réalisée pour
réunir l'ensemble des qualités recherchées pour le développement de
\emph{parsers} (rapidité d'écriture, garanties fortes sur le
fonctionnement des outils et efficacité des programmes produits).
Cette quatrième mouture, \FAceSL, résulte de la fusion entre le
langage spécifique de description des objets analysés et le langage de
programmation: on utilise directement le langage OCaml pour les deux
usages. Pour cela, le processeur \texttt{camlp4} a été employé pour la
génération automatique des types et des fonctions à partir de
descriptions brèves des structures à disséquer.


\subsection{Autre application: MRT}

BGP (\emph{Border Gateway Protocol}~\cite{rfc4271}) est un autre
protocole étudié par le laboratoire. Il s'agit du protocole de routage
utilisé pour interconnecter les différents réseaux qui forment
l'internet. Il existe de nombreuses RFC décrivant BGP, ses extensions,
ainsi que des protocoles connexes. En particulier, MRT
(\emph{Multi-Threaded Routing Toolkit}~\cite{rfc6396}) est un format
d'échange utilisé pour archiver et transmettre l'ensemble des annonces
vues par un routeur.

Certains projets proposent d'accéder aux informations de routage de
l'internet collectées depuis plusieurs points dans le monde, et
exportées au format MRT. Ces données sont d'un grand intérêt pour
analyser l'état de l'internet, détecter et comprendre d'éventuels
incidents affectant les informations de routage. L'observatoire de la
résilience de l'internet français~\cite{observatoire}, mis en place
par l'ANSSI en 2012, utilise donc cette source de données et doit donc
disposer d'outils capables d'interpréter les fichiers MRT. Le projet
RIS (\emph{Routing Information Service}) fournit trois fois par jour
une vision complète de~16~routeurs disséminés sur la planète, ce qui
correspond à plusieurs centaines de méga-octets par jour, d'où le
besoin d'avoir des dissecteurs robustes et efficaces.

Deux outils étaient utilisés au sein du laboratoire pour analyser
cette grande quantité de données au format MRT. Le premier est un
outil libre écrit en C, dont la qualité de code laisse à
désirer\footnote{Cet outil en C se terminait parfois de manière
  brutale sur certains fichiers sans donner aucune explication.}. Le
second est un développement interne en OCaml, plus fiable que le
premier.

Afin de valider la possibilité d'écrire rapidement avec \FAceSL des
\emph{parsers} efficaces et robustes, un nouveau développement des
outils d'analyse pour MRT a été réalisé. Il a suffi de~4~jours pour
décrire en \FAceSL les structures pertinentes pour les études menées
et obtenir un outil indépendant des deux autres, plus rapide que
l'implémentation en OCaml pré-existante et plus fiable que
l'implémentation en C.



\section{Présentation de \FAceSL par l'exemple: le format TAR}
\label{sec:tar}

Le tableau~\ref{tab:tar-format} décrit deux versions de l'en-tête
utilisé dans les archives TAR: le format original (colonne TAR) et une
variante plus récente (colonne \texttt{ustar}). Pour des raisons de
compatibilité, les valeurs numériques sont systématiquement stockées
sous la forme d'une chaîne de caractère représentant la valeur
numérique en octal\footnote{Cette méthode permet d'éviter des
  difficultés d'encodage telles que la prise en compte de
  l'\emph{endianness}, mais au prix d'une plus grande consommation
  mémoire.}. L'en-tête est contenu dans un «~bloc~» de 512~octets, et
le contenu du fichier qui suit l'en-tête est lui-aussi complété par
des caractères nuls pour former des blocs de 512~octets.

Le champ à l'offset~156 décrit le type de fichier, et a été étendu par
\texttt{ustar}. Le tableau \ref{tab:tar-filetypes} récapitule les
différentes valeurs qu'il peut prendre.

\begin{table}
  \begin{center}
    \begin{tabular}{|r|r|l|l|}
      \hline
      \multicolumn{1}{|c|}{\bf Offset} &
      \multicolumn{1}{c|}{\bf Long.} &
      \multicolumn{2}{c|}{\bf Description} \\
      & & \multicolumn{1}{c|}{\bf TAR} &
      \multicolumn{1}{c|}{\bf \tt ustar} \\
      \hline

      \hline
        0 & 100 & \multicolumn{2}{l|}{Nom du fichier} \\
      \hline
      100 &   8 & \multicolumn{2}{l|}{Permissions} \\
      \hline
      108 &   8 & \multicolumn{2}{l|}{UID} \\
      \hline
      116 &   8 & \multicolumn{2}{l|}{GID} \\
      \hline
      124 &  12 & \multicolumn{2}{l|}{Taille du fichier} \\
      \hline
      136 &  12 & \multicolumn{2}{l|}{\emph{Timestamp} de la dernière modification} \\
      \hline
      148 &   8 & \multicolumn{2}{l|}{Somme de contrôle de l'en-tête} \\
      \hline
      156 &   1 & Indicateur de lien & Type de fichier \\
      \hline
      157 & 100 & \multicolumn{2}{l|}{Nom du fichier pointé par le lien} \\
      \hline
      257 &   6	& \multicolumn{1}{c|}{-} & Indicateur \texttt{"ustar"} \\
      \hline
      263 &   2	& \multicolumn{1}{c|}{-} & Version \texttt{ustar} ("00") \\
      \hline
      265 &  32 & \multicolumn{1}{c|}{-} & Propriétaire \\
      \hline
      297 &  32 & \multicolumn{1}{c|}{-} & Groupe propriétaire \\
      \hline
      329 &   8 & \multicolumn{1}{c|}{-} & Numéro majeur du périphérique \\
      \hline
      337 &   8 & \multicolumn{1}{c|}{-} & Numéro mineur du périphérique \\
      \hline
      345 & 155 & \multicolumn{1}{c|}{-} & Préfixe \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Description de l'en-tête TAR.}
  \label{tab:tar-format}
\end{table}

\begin{table}
  \begin{center}
    \begin{tabular}{|>{\tt}c|l|c|}
      \hline
      \multicolumn{1}{|c|}{\bf Caractère} &
      \multicolumn{1}{c|}{\bf Description} &
      \multicolumn{1}{c|}{\bf \tt ustar} \\
      \hline

      \hline
      <NUL>, 0 & fichier ordinaire & - \\
      1 & lien dur & - \\
      2 & lien symbolique & - \\
      \hline
      3 & périphérique en mode caractères & oui \\
      4 & périphérique en mode blocs & oui \\
      5 & répertoire & oui \\
      6 & file FIFO & oui \\
      7 & fichier contigu & oui \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Valeurs du champ «~Indicateur de lien/Type de fichier~».
    La colonne \texttt{ustar} indique si la valeur est spécifique à
    la version étendue du format.}
  \label{tab:tar-filetypes}
\end{table}

\begin{table}
  \begin{center}
    \begin{tabular}{|r|r|l|}
      \hline
      \multicolumn{1}{|c|}{\bf Offset} &
      \multicolumn{1}{c|}{\bf Long.} &
      \multicolumn{1}{c|}{\bf Description} \\
      \hline

      \hline
        0 & 512 & En-tête TAR, complété par des zéros \\
      \hline
      512 & \emph{«~Taille du fichier~»}, alignée à 512~octets & Contenu du fichier, complété par des zéros \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Description d'une entrée TAR.}
  \label{tab:tar-entry}
\end{table}


\subsection{Une première implémentation}

Afin d'utiliser notre pré-processeur pour décrire les fichiers au
format TAR, commençons par décrire les valeurs de ce champ
«~Indicateur de lien/Type de fichier~». Il s'agit d'une énumération
sur 8~bits qui s'écrit avec le nouveau mot-clé \texttt{enum}:
\begin{lstlisting}
enum file_type (8, UnknownVal UnknownFileType, []) =
  | 0 -> NormalFile
  | 0x30 -> NormalFile
  | 0x31 -> HardLink
  | 0x32 -> SymbolicLink
  | 0x33 -> CharacterSpecial
  | 0x34 -> BlockSpecial
  | 0x35 -> Directory
  | 0x36 -> FIFO
  | 0x37 -> ContiguousFile
\end{lstlisting}

Ensuite, on peut décrire l'enregistrement contenant les différents
champs constituant d'un en-tête à l'aide du mot clé \texttt{struct},
qui ressemble à la description d'un enregistrement OCaml, mais qui
accepte des types enrichis nommés \FAceSLTypes:
\begin{lstlisting}
let int_of_tarstring octal_value =
  int_of_string ("0o" ^ octal_value)

struct tar_header = {
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
  hdr_padding : binstring(12);
}

struct tar_entry = {
  header : tar_header;
  file_content : binstring(int_of_tarstring header.file_size);
  file_padding : binstring(512 - ((int_of_tarstring header.file_size) % 512))
}

alias tar_file = list of tar_entry;
\end{lstlisting}

Le code resultant du pré-processeur permet alors d'ouvrir une archive
simplement à l'aide de la fonction \texttt{parse\_tar\_file}, qui
prend en argument la chaîne de caractères correspondant au contenu du
fichier. Afin de traiter des données importantes de manière efficace,
il est également possible de produire une version du \emph{parser} en
mode flux, qui repose sur la bibliothèque \texttt{lwt}. Pour cela, il
suffit de redéfinir l'alias en lui adjoignant l'option
\texttt{with\_lwt} et d'utiliser cette fois la fonction
\texttt{lwt\_parse\_tar\_file}, comme le montre l'exemple suivant:
\begin{lstlisting}
alias tar_file [with_lwt] = list of tar_entry;

let handle_filename filename =
  Lwt_unix.openfile filename [Unix.O_RDONLY] 0 >>= fun fd
  lwt_parse_tar_file (input_of_fd filename fd) >>= fun tar_file
  let print_filename entry = print_string entry.file_name in
  List.iter print_filename tar_file;
  return ()

let _ =
  Lwt_unix.run (handle_filename "test.tar");
\end{lstlisting}


\subsection{Pour aller plus loin}
\label{sec:aller-plus-loin}

La première version proposée est fonctionnelle, mais si l'on souhaite
proprement prendre en compte les vieilles archives, ne contenant pas
l'en-tête étendu commençant par le marqueur \texttt{ustar}, on peut
réécrire la description de l'en-tête de la manière suivante, en
séparant l'en-tête en deux morceaux, dont un est déclaré optionnel.
\begin{lstlisting}
struct ustar_header = {
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
}

struct tar_header = {
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  optional ustar_header : ustar_header;
  hdr_padding : binstring;
}

struct tar_entry = {
  header : container(512) of tar_header;
  file_content : binstring(header.file_size);
  file_padding : binstring(512 - (header.file_size % 512))
  checksum_verification : check of check_crc32 (header, file_content, file_padding);
}

alias tar_file = list of tar_entry;
\end{lstlisting}

Avec cette seconde version, on utilise un conteneur de 512 octets pour
lire l'en-tête. Si l'en-tête est étendu, le champ
\texttt{ustar\_header} sera peuplé par la fonction
\texttt{parse\_ustar\_header} et le champ \texttt{hdr\_padding}, une
chaîne binaire consommant les octets restants du conteneur,
contiendra~12~octets; dans le cas contraire, la fonction échouera, le
champ \texttt{ustar\_header} vaudra \texttt{None} et
\texttt{hdr\_padding} aura une longueur de 255~octets.

Le lecteur attentif aura également remarqué l'ajout d'un champ
intitulé \texttt{checksum\_verification}, qui permet d'exécuter une
vérification de la somme de contrôle une fois l'entrée TAR entièrement
disséquée. Cette ligne ne produit pas de champ dans le type OCaml
\texttt{tar\_entry} généré, mais appelle la fonction
\texttt{check\_crc32}\footnote{une fonction à écrire dont le prototype
  attendu est \lstinline+tar_header -> string -> string -> unit+ qui
  pourra lever une exception en cas d'erreur sur la somme de
  contrôle.}  sur les champs déjà disséqués. On pourrait utiliser ce
type de champs pour vérifier d'autres propriétés (le champ
\texttt{hdr\_padding} et les champs inutilisés sont par exemple censés
ne contenir que des caractères nuls).

\medskip

Le format TAR faisant un usage important des chaînes de caractères
encodant une valeur numérique, on pourrait aussi créer de toute pièce
un nouveau type, \texttt{tar\_numstring}, de la manière
suivante\footnote{Pour des raisons historiques, un champ de 8~octets
  sera terminé par un espace ou un caractère nul, ne laissant ainsi en
  pratique que 7~octets pour encoder la valeur.}:
\begin{lstlisting}
type tar_numstring = int

let parse_tar_numstring len input =
  let octal_value = parse_string (len - 1) input in
  drop_bytes 1 input;
  int_of_string ("0o" ^ octal_value)

let dump_tar_numstring len v =
  Printf.printf "%*.*o\x00" len len v

let print_tar_numstring ?indent:(indent="") ?name:(name="numstring") v =
  Printf.sprintf "%s%s: %d (%o)\n" indent name v v
\end{lstlisting}

En effet, définir un nouveau type consiste simplement à déclarer un
type OCaml et à écrire les fonctions de base pour traiter ce type, ce
qui permet d'étendre facilement l'expressivité de \FAceSL à l'aide de
\FAceSLTypes personnalisés.

Une fois ce nouveau type défini, on peut modifier les champs
représentant des valeurs numériques en octal en replaçant le type
\texttt{string(n)} par \texttt{tar\_numstring(n)}.



\section{Description des extensions du langage}
\label{sec:description}


L'idée générale de \FAceSL est d'interpréter des descriptions courtes
rédigées par le développeur et de générer automatiquement:
\begin{itemize}
\item des types OCaml décrivant des structures binaires;
\item des fonctions pour disséquer les objets correspondants depuis
  une chaîne de caractère (\texttt{parse\_t}) ou depuis un flux
  (\texttt{lwt\_parse\_t});
\item des fonctions pour exporter les objets sous forme binaire
  (\texttt{dump\_t}) ou dans une représentation imprimable
  (\texttt{print\_t}).
\end{itemize}

\noindent
Ces fonctions correspondront au type suivant:
\begin{lstlisting}
val parse_t : string_input -> t
val lwt_parse_t : lwt_input -> t
val dump_t : t -> string
val print_t : ?indent:string -> ?name:string -> t -> string
\end{lstlisting}

La fonction \texttt{print} accepte des options pour modifier
l'indentation et le nom de la structure à afficher. Les fonctions
\texttt{parse}, \texttt{lwt\_parse} et \texttt{dump} peuvent
éventuellement accepter des paramètres supplémentaires.

Les sections suivantes décrivent les différentes constructions
apportées par \FAceSL, et des exemples permettant de comprendre ce
qu'elles apportent. La grammaire détaillée est donnée en annexe.


\subsection{\'Enumérations}

La première construction ajoutée par \FAceSL est l'énumération, qui
ressemble à l'\texttt{enum} du C, le typage fort en plus. Par exemple,
la déclaration suivante:
\begin{lstlisting}
enum tls_version (16, UnknownVal V_Unknown, [with_lwt]) =
  | 0x0002 -> V_SSLv2, "SSLv2"
  | 0x0300 -> V_SSLv3, "SSLv3"
  | 0x0301 -> V_TLSv1, "TLSv1.0"
  | 0x0302 -> V_TLSv1_1, "TLSv1.1"
  | 0x0303 -> V_TLSv1_2, "TLSv1.2"
\end{lstlisting}

\noindent correspond au champ encodant la version du protocole SSL/TLS
sur un entier~16~bits, et génère le type somme suivant:
\begin{lstlisting}
type tls_version =
  | V_SSLv2 | V_SSLv3 | V_TLSv1 | V_TLSv1_1 | V_TLSv1_2
  | V_Unknown of int
\end{lstlisting}

\noindent ainsi que les fonctions suivantes:
\begin{lstlisting}
val string_of_tls_version : tls_version -> string
val int_of_tls_version : tls_version -> int
val tls_version_of_int : int -> tls_version
val tls_version_of_string : string -> tls_version

val parse_tls_version : string_input -> tls_version
val lwt_parse_tls_version : lwt_input -> tls_version
val dump_tls_version : tls_version -> string
val print_tls_version : ?indent:string -> ?name:string -> tls_version -> string
\end{lstlisting}

Les quatre premières fonctions générées permettent simplement de
convertir le type énumération depuis et vers les entiers et les
chaînes de caractères. Il est possible de décrire comment
\texttt{tls\_version\_of\_int} doit traiter une valeur non fournie
dans l'énumération: dans l'exemple ci-dessus, \texttt{UnknownVal
  V\_Unknown} indique qu'il faut renvoyer une valeur
\texttt{V\_Unknown i}, où \texttt{i} est la valeur non
reconnue. L'autre comportement possible est de lever une exception en
cas de motif inconnu.

Les quatre fonctions suivantes fournissent les services de plus haut
niveau décrits précédemment.


\subsection{\FAceSLTypes}

Avant de poursuivre avec les constructions apportées par \FAceSL, il
est nécessaire de décrire les \FAceSLTypes, les types binaires compris
par \texttt{struct} et \texttt{union}.

\medskip

Tout d'abord, \FAceSL propose des types de base pour lesquels les
implémentations des fonctions \texttt{parse}, \texttt{lwt\_parse},
\texttt{dump} et \texttt{print} sont déjà disponibles: les entiers non
signés, les adresses IPv4 et IPv6 encodées en binaire et les chaînes
de caractères.

En plus de ces types scalaires, le type \texttt{list} permet de
décrire des listes d'objets du même type. Le type \texttt{container}
sert à encapsuler un sous-type en spécifiant la taille de la
sous-chaîne à lire depuis l'entrée. Nous l'avons utilisé pour la
gestion de l'en-tête TAR qui est contenu dans un bloc de 512~octets
mais dont la partie utile peut varier (selon qu'il soit conforme au
standard \texttt{ustar} ou non): \lstinline+container(512) of tar_header+

\medskip

Pour les chaînes de caractères et les listes, les \emph{parsers}
générés par défaut essaient de lire l'ensemble de la chaîne qui leur
est passée en entrée. On peut cependant préciser avec une expression
entre parenthèses la taille en octets attendue pour une chaîne de
caractères en octets ou le nombre d'éléments attendus pour une
liste (\lstinline+binstring(header.file_size)+).

Un autre format fréquemment rencontré pour les chaînes de caractères
ou les listes est de faire précéder la chaîne ou la liste par un champ
longueur qui définit le nombre d'octets utiles pour l'élément qui
suit; on peut spécifier à l'aide de crochets qu'un tel type est
attendu: \texttt{\textbf{list} [uint16] \textbf{of} uint16} permet de
décrire une liste d'entiers sur 16~bits dont la longueur totale en
octets est codées sur un entier 16~bits\footnote{Ce type particulier
  peut servir à décrire la liste des suites cryptographiques
  (\emph{ciphersuites}) proposées par un client dans le protocole
  TLS.}.

\medskip

Enfin, n'importe quel type peut être utilisé comme type personnalisé,
dès lors qu'il existe un type OCaml valide, ainsi que les fonctions
\texttt{parse}, \texttt{dump} et \texttt{print} correspondantes. Il
existe deux moyens de construire de nouveaux types:
\begin{itemize}
\item à l'aide de \texttt{struct} et \texttt{union} décrits
  ci-dessous;
\item en écrivant un nouveau type OCaml et les fonctions nécessaires,
  comme nous l'avons fait pour \texttt{tar\_numstring} dans l'exemple
  de la section~\ref{sec:aller-plus-loin}.
\end{itemize}


\subsection{Structures}

Les structures que l'on peut exprimer en \FAceSL sont des
enregistrements qui viennent avec des fonctions \texttt{parse},
\texttt{dump} et \texttt{print} auto-générées.

Un exemple simple illustrant le mot clé \texttt{struct} est donné par
les messages d'alerte du protocole TLS. De tels messages contiennent
deux octets: le niveau et le type de l'alerte.

 À partir de deux types
énumérations sur 8~bits, on peut créer l'enregistrement à l'aide du
code suivant:
\begin{lstlisting}
enum tls_alert_level (8, UnknownVal AL_Unknown, []) =
  | 1 -> AL_Warning, "Warning"
  | 2 -> AL_Fatal, "Fatal"

enum tls_alert_type (8, UnknownVal AT_Unknown, []) =
  | 0 -> AT_CloseNotify, "CloseNotify"
  | 10 -> AT_UnexpectedMessage, "UnexpectedMessage"
    ...
  | 115 -> AT_UnknownPSKIdentity, "UnknownPSKIdentity"

struct tls_alert = {
  alert_level : tls_alert_level;
  alert_type : tls_alert_type
}
\end{lstlisting}

L'option \texttt{with\_lwt} déclenche la génération de la fonction
\texttt{lwt\_parse}. L'option \texttt{with\_exact} permet de créer une
fonction \texttt{exact\_parse} qui vérifie que la chaîne de caractères
fournie en entrée correspond exactement à l'objet disséqué et qu'il
n'existe pas d'octets à la fin de la chaîne de caractères. L'option
\texttt{top} est un raccourci pour les deux options précédentes,
puisqu'elle décrit un objet au niveau le plus haut. Enfin, il est
possible d'ajouter des paramères aux fonctions \texttt{parse} et
\texttt{dump} générées avec l'option \texttt{param}; ces paramètres
pourront être utilisés dans les expressions entre parenthèses (pour
indiquer une longueur ou pour transmettre un argument à un type
personnalisé), comme nous le verrons dans le prochain exemple.


\subsection{Unions}

Empruntant encore la terminologie du langage C, les unions sont en
réalité des types somme augmentés par un constructeur par
défaut. L'idée est d'utiliser un discriminant passé en argument à la
fonction \texttt{parse} pour en déduire le constructeur du type somme
à utiliser. Ce discriminant va être comparé aux différents motifs
proposés dans la description de l'union, et le constructeur adapté
sera choisi.

\shorthandoff{:}
\begin{tabbing}
  \textit{union} ::= \textbf{\tt union} \= \textit{identifiant} (\textit{comportement}, \textit{union\_options}) = \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \> ... \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \\
  \textit{comportement} ::\= = \= \textit{Constructor} \\
  \> $\vert$ \> \textit{Constructor} \textbf{\tt of} \textit{\FAceSLType} \\
  \\
  \textit{struct\_option} ::\= = \= \textbf{\tt with\_lwt} \\
  \> $\vert$ \> \textbf{\tt with\_exact} \\
  \> $\vert$ \> \textbf{\tt top} \\
  \> $\vert$ \> \textbf{\tt enrich} \\
  \> $\vert$ \> \textbf{\tt exhaustive} \\
  \> $\vert$ \> \textbf{\tt param} \textit{expression} \\
\end{tabbing}
\shorthandon{:}

Si on ne souhaite pas enrichir l'union ou que le discriminant n'a pas
une valeur attendue, on utilise le constructeur par défaut, qui
récupère par défaut la chaîne de caractères restant\footnote{Il est
  possible de spécifier un autre \FAceSLType pour le constructeur par
  défaut en le spécifiant dans le comportement.}.

L'enrichissement de l'union \texttt{u} est contrôlé par une variable
globale \texttt{enrich\_u}, initialisée à \texttt{true} si l'option
\texttt{enrich} est activée, à \texttt{false} sinon. De plus, on peut
surcharger cette valeur par un argument optionnel \texttt{enrich} de
la fonction \texttt{parse}. Si l'option \texttt{exhaustive} est
positionnée, le \emph{pattern matching} généré pour l'enrichissement
sera exclusivement composé des motifs de la description (sans motif
par défaut «~\texttt{\_}~»).

Les options \texttt{with\_lwt}, \texttt{with\_exact}, \texttt{top} et
\texttt{param} ont le même sens que pour les structures.

\medskip

Le protocole BGP définit la notion de système autonome (AS), un numéro
identifiant un opérateur. Initialiement, les AS étaient représentés
sur 16~bits, mais cela n'est plus suffisant désormais et les AS sont
parfois décrits sur 32~bits. L'exemple suivant montre comment décrire
un AS avec une union, et comment employer le type généré dans une
structure:
\begin{lstlisting}
union autonomous_system (UnparsedAS, [enrich]) =
  | 16 -> AS16 of uint16
  | 32 -> AS32 of uint32

struct bgp_as_path_segment [param as_size] = {
  path_segment_type : uint8;
  path_segment_length : uint8;
  path_segment_value : list(path_segment_length) of autonomous_system(as_size)
}
\end{lstlisting}

Le type \texttt{autonomous\_system} sera vu comme un
entier~16~ou~32~bits selon le discriminant qui lui est passé. La
déclaration de la structure \texttt{bgp\_as\_path\_segment} conduit à
la génération d'une fonction \texttt{parse\_bgp\_as\_path\_segment}
qui prend un argument supplémentaire (\texttt{as\_size}), puis tente
de lire le type de segment (un octet), la longueur du segment (un
autre octet), puis une liste contenant \texttt{path\_segment\_length}
éléments du type union défini. On remarquera que la valeur
\texttt{as\_size} est alors passée comme discriminant à
\texttt{parse\_autonomous\_system}.


Voici des extraits du code généré par \FAceSL à partir des deux types
ci-dessus:
\begin{lstlisting}
let enrich_autonomous_system = ref true

type autonomous_system = | AS16 of int | AS32 of int | UnparsedAS of string

let parse_autonomous_system ?enrich:(enrich = false) discriminator input =
  if !enrich_autonomous_system || enrich then
    (match discriminator with
     | 16 -> AS16 (parse_uint16 input)
     | 32 -> AS32 (parse_uint32 input)
     | _ -> UnparsedAS (parse_rem_string input))
  else UnparsedAS (parse_rem_string input)

type bgp_as_path_segment =
  { path_segment_type : int; path_segment_length : int;
    path_segment_value : autonomous_system list }

let parse_bgp_as_path_segment as_size input =
  let path_segment_type = parse_uint8 input in
  let path_segment_length = parse_uint8 input in
  let path_segment_value = parse_list path_segment_length
      (parse_autonomous_system as_size) input
  in
    {
      path_segment_type = path_segment_type;
      path_segment_length = path_segment_length;
      path_segment_value = path_segment_value;
    }
\end{lstlisting}

% TODO: ~enrich should be Default|AlwaysOn|AlwaysOff|OnForDepth of int


\subsection{Alias}

Pour permettre de produire simplement des fonctions \texttt{parse},
\texttt{dump} et \texttt{print} pour des listes, on peut déclarer des
alias comme dans le cas du format TAR.

\shorthandoff{:}
\begin{tabbing}
  \textit{alias} ::= \textbf{\tt alias} \textit{identifiant} = \textit{\FAceSLType} \\
\end{tabbing}
\shorthandon{:}


\subsection{Types ASN.1}

Pour décrire les structures ASN.1, il est nécessaire de disposer des
types ASN.1 de bases.

\shorthandoff{:}
\begin{tabbing}
  \textit{ASN1Header} ::= \textit{ASN1Class} \textbf{\tt *} \textit{ASN1Tag} \\
  \\
  \textit{ASN1Type} ::= \textit{ASN1Header} \texttt{option} \textbf{\tt *}
                        \textit{ASN1TypeContent} \\
  \\
  \textit{ASN1TypeContent} ::\= = \= \textbf{\tt asn1\_bool} \\
  \> $\vert$ \> \textbf{\tt asn1\_integer} \\
  \> $\vert$ \> \textbf{\tt asn1\_bitstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_enumerated} \\
  \> $\vert$ \> \textbf{\tt asn1\_octetstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_null} \\
  \> $\vert$ \> \textbf{\tt asn1\_oid} \\
  \> $\vert$ \> \textbf{\tt asn1\_list} \textbf{\tt of} \textit{ASN1Type} \\
  \> $\vert$ \> \textbf{\tt asn1\_container} \textbf{\tt of} \textit{ASN1Type} \\
  \> $\vert$ \> \textbf{asn1\_anything} \\
  \> $\vert$ \> \textit{custom type} \\
  \> $\vert$ \> \textit{custom type} (\textit{paramètres}) \\
\end{tabbing}
\shorthandon{:}

Les premiers \textit{ASN1TypeContents} décrivent le contenu des objets
ASN.1 classiques: booléens, entiers, chaînes de bit ou d'octets, OIds,
etc. Le type \texttt{asn1\_enumerated} correspond à un cas particulier
des chaînes de bit pour représenter un \texttt{bitmap} (par exemple,
le \emph{KeyUsage} X.509). Le conteneur permet d'encapsuler facilement
un type ASN.1 dans un objet ASN.1 de type construit (on trouve de tels
conteneurs pour encapsuler la version ou les extensions dans un
certificat X.509).

Pour chaque type de base \texttt{T}, les fonctions
\texttt{parse\_T\_content}, \texttt{dump\_T\_content} et
\texttt{print\_T\_content} sont déjà fournies et permettent de traiter
le contenu de ces types. Des fonctions plus haut niveau, simplement
nommée \texttt{parse\_T}, \texttt{dump\_T} et \texttt{print\_T}
prennent en compte l'en-tête ASN.1 par défaut. De plus, des fonctions
permettent respectivement de \emph{parser} et de \emph{dumper} des
objets ASN.1 à partir d'un en-tête et d'un type contenu:
\begin{lstlisting}
val parse_asn1_object : ?name:string -> asn1_header ->
                        (string_input -> 'a) -> string_input -> 'a
val dump_asn1_object : asn1_header -> bool ->
                       ('a -> string) -> 'a -> string
\end{lstlisting}

% Pour que cette représentation des types ASN.1 soit complète, il
% faudrait pouvoir ajouter des contraintes sur les champs de bits
% d'énumération ou sur les chaînes de caractères
% (\texttt{PrintableString}, \texttt{UTF8String}, etc.).


\subsection{Alias ASN.1}

Les structures ASN.1 peuvent s'exprimer simplement à l'aide des
structures binaires avec des types ASN.1. Cependant, de telles
structures ne décrivent que le contenu de l'objet. Pour finaliser la
description de ces objets, il est nécessaire de leur associer un
en-tête par défaut. C'est à cela que sert la contruction
\texttt{asn1\_alias}.

\shorthandoff{:}
\begin{tabbing}
  \textit{alias} ::= \textbf{\tt asn1\_alias} \textit{identifiant} = \textit{ASN1Type} \\
\end{tabbing}
\shorthandon{:}

Ainsi la description d'un objet ASN.1 ressemblera à l'exemple suivant
(la description d'une clé privée RSA):
\begin{lstlisting}
struct private_rsa_key_content = {
  version : asn1_integer;
  modulus : asn1_integer;
  publicExponent : asn1_integer;
  privateExponent : asn1_integer;
  prime1 : asn1_integer;
  prime2 : asn1_integer;
  exponent1 : asn1_integer;
  exponent2 : asn1_integer;
  coefficient : asn1_integer;
}

asn1_alias private_rsa_key = (C_Universal, T_Sequence), private_rsa_key_content
\end{lstlisting}


% TODO: décrire parse_private_rsa_key avec parse_asn1_object et parse_private_rsa_key_content

% TODO:
%  - unions ASN.1 ?
%  - optional fields in ASN.1 structures ?
%  - AO_EnrichRawString -> pour struct!
%  - AO_EnrichASN1Info
%  - AO_TopLevel



\section{Applications}


\subsection{Quelques mots sur l'implémentation \texttt{camlp4}}

L'implémentation complète de \FAceSL comporte
\begin{itemize}
\item des pré-processeurs \texttt{camlp4}, qui comportent environ
  1200~lignes de code;
\item des bibliothèques annexes pour implémenter la gestion des types
  de base, sur 1300~lignes de code.
\end{itemize}

Ce travail a nécessité de comprendre le fonctionnement de
\texttt{camlp4} dont la documentation n'est pas toujours facile
d'accès, mais une fois les différents types de \texttt{camlp4}
assimilés, il est possible de réaliser des manipulations extrêmement
riches sur l'arbre de syntaxe abstraite.

% Pour la présentation
% \TODO{Comportement surprenant: camlp4o <preprocessors> <fichier.ml> a
%   un comportement différent selon que la sortie standard est un pipe
%   ou une console...}


\subsection{TLS et X.509}



 Dans le cas de TLS, l'objectif était d'effectuer un
état des lieux de la qualité des serveurs TLS dans le monde, et son
évolution dans le temps. Ces travaux ont fait l'objet d'une
publication à ACSAC~2012~\cite{ACSAC2012}.


Le point de départ de ces travaux sur les \emph{parsers} était
l'analyse de données TLS~\cite{rfc5246} contenant des certificats
X.509~\cite{rfc5280} (structures ASN.1 encodées au format DER). Il
s'agit donc logiquement de la première application concrète de
\FAceSL.

À ce jour, une grande partie des messages du protocole a pu être
décrite à l'aide de \FAceSL, ainsi que les certificats X.509. La
répartition du nombre de lignes de code est la suivante:
\begin{itemize}
\item énumérations TLS\footnote{L'énumération décrivant l'ensemble des
    suites cryptographiques comporte en particulier~300~valeurs.}:
  500~lignes;
\item description des messages TLS: 150~lignes;
\item description des certificats X.509 : 100~lignes;
\item outil pour tester les versions et suites cryptographiques
  supportées par un serveur donné, et afficher la partie en clair de
  l'échange: 250~lignes.
\end{itemize}

%\TODO{Exemple de struct/union} ?

Ainsi, en environ 1000~lignes de code\footnote{Ce décompte ne comprend
  évidemment pas le pré-processeur ni les fonctions auxiliaires
  fournissant les services de base (\texttt{parse\_uint8} et
  \texttt{dump\_ipv4} par exemple).}, il a été possible de décrire une
grande partie du protocole TLS ainsi qu'un outil de test.

À partir de ces \emph{parsers}, d'autres outils ont été écrits pour
analyser plusieurs centaines de giga-octets de réponses TLS provenant
de plusieurs campagnes de mesure sur internet. Les résultats de ces
analyses ont fait l'objet d'une publication~\cite{ACSAC2012}.

\medskip

Afin d'arriver à une implémentation complète d'une pile TLS, il
faudrait encore ajouter les éléments suivants:
\begin{itemize}
\item détailler les extensions X.509 qui ne sont que partiellement
  enrichies aujourd'hui;
\item écrire et animer l'automate du protocole de négociation TLS (à
  ce jour, seule une animation rudimentaire a été développée pour
  réaliser le programme de tests);
\item ajouter les appels aux fonctions cryptographiques pour mettre
  réellement en \oe uvre le tunnel négocié.
\end{itemize}


\subsection{MRT}

BGP est l'un des protocoles étudiés par le laboratoire sécurité des
réseaux et protocoles. Le format d'échange utilisé pour archiver et
transmettre l'ensemble des annonces vues par une sonde est
\emph{Multi-Threaded Routing Toolkit} (MRT)~\cite{rfc6396}.

Là encore, deux outils étaient utilisés au sein du laboratoire pour
analyser une grande quantité de données au format MRT, le premier est
un outil libre écrit en C\footnote{Il est à noter que cet outil en C
  se terminait parfois de manière brutale sur certains fichiers sans
  aucune explication.}, le second est un développement interne en
OCaml. Il a suffi de~4~jours pour décrire en \FAceSL les structures
MRT pertinentes pour les études menées au laboratoire et obtenir un
outil indépendant des deux autres, plus rapide que l'implémentation en
OCaml pré-existante et plus fiable que l'implémentation en C.

La description des messages MRT nécessite moins de~300~lignes de code,
alors que l'outil permettant d'afficher le contenu disséqué de manière
similaire aux outils existants en comporte~250. L'implémentation
précédente en OCaml comptait~1200 lignes environ.


\subsection{TAR}

Développée pour les besoin de cet article, la description avec \FAceSL
du format d'archive TAR en moins de~100~lignes a permis d'écrire
ensuite un outil pour lister une archive TAR en quelques lignes. Il ne
s'agit cependant pas d'une réelle application, mais uniquement d'un
exemple.


\section{Conclusion et perspectives}

L'écriture de \FAceSL, qui résulte de la fusion du langage spécifique
utilisé pour décrire les objets étudiés et du langage permettant de
raisonner sur les objets construits, a permis d'obtenir, à l'aide
de~2500~lignes de code, un générateur de dissecteurs réunissant toutes
les propriétés recherchées:
\begin{itemize}
\item rapidité d'écriture pour étendre avec de nouveaux types;
\item expressivité des types;
\item garanties fortes sur le fonctionnement des outils;
\item efficacité des programmes produits.
\end{itemize}

Deux projets écrits en Python présentent des similarités avec les
travaux exposés ici:
\begin{itemize}
\item \texttt{scapy}~\cite{scapy}, une boîte à outils pour manipuler les paquets
  réseau; ce projet permet également de définir rapidement de nouveaux
  protocoles réseau pour étendre la boîte à outils;
\item \texttt{hachoir}~\cite{hachoir}, une bibliothèque pour écrire rapidement des
  dissecteurs pour des formats de fichiers.
\end{itemize}
\noindent Le langage Python semble un candidat naturel pour réaliser
ce genre de projet, grâce à ses capacités d'introspection. Il est
intéressant de remarquer que l'utilisation d'un pré-processeur en OCaml
pour manipuler du OCaml permet d'arriver au même résultat.

\medskip

Parmi les développements prévus pour \FAceSL, les pistes suivantes
sont envisagées:
\begin{itemize}
\item ajout d'options pour améliorer la dissection ASN.1 (par exemple,
  lors de la dissection d'un certificat X.509, il est utile de
  conserver la chaîne de caractère décrivant le bloc de données à
  signer, \texttt{tbsCertificate}, pour pouvoir simplement vérifier la
  signature du certificat);
\item description de nouveaux formats de fichiers et de nouveaux
  protocoles (DNS, \texttt{pcap}, etc.);
\item automatisation de l'animation des protocoles par la génération
  d'automates permettant l'étude d'exécutions du protocoles.
\end{itemize}

%\TODO{ASN.1: ajout d'options, ajout des unions et de spécifités}


\bibliographystyle{unsrt}
\bibliography{biblio,rfc}

% \begin{thebibliography}{10}
% \bibitem{eff-observatory}
% {E}lectronic~{F}rontier {F}oundation.
% \newblock {T}he {EFF} {SSL} {O}bservatory, 2010-2012.
% \newblock \url{https://www.eff.org/observatory}

% \bibitem{eckersley-obs1}
% P.~{E}ckersley and J.~{B}urns.
% \newblock {A}n {O}bservatory for the {SSL}iverse, {T}alk at {D}efcon 18, 2010.

% \bibitem{eckersley-obs2}
% P.~{E}ckersley and {J}. {B}urns.
% \newblock {I}s the {SSL}iverse a safe place?, {T}alk at {27C3}, 2010.

% \bibitem{ACSAC2012}
% Olivier Levillain.
% \newblock One {Y}ear of {SSL} {M}easurement.
% \newblock In {\em ACSAC}, 2012.

% \bibitem{rfc5246}
% T.~Dierks and E.~Rescorla.
% \newblock {The Transport Layer Security (TLS) Protocol Version 1.2}.
% \newblock RFC 5246 (Proposed Standard), August 2008.
% \newblock Updated by RFCs 5746, 5878, 6176.

% \bibitem{rfc5280}
% D.~Cooper, S.~Santesson, S.~Farrell, S.~Boeyen, R.~Housley, and W.~Polk.
% \newblock {Internet X.509 Public Key Infrastructure Certificate and Certificate
%   Revocation List (CRL) Profile}.
% \newblock RFC 5280 (Proposed Standard), May 2008.

% \bibitem{rfc6396}
% L.~Blunk, M.~Karir, and C.~Labovitz.
% \newblock {Multi-Threaded Routing Toolkit (MRT) Routing Information Export
%   Format}.
% \newblock RFC 6396 (Proposed Standard), October 2011.

% \bibitem{scapy}
% P.~{B}iondi and the~{S}capy community.
% \newblock {S}capy, 2003-2012.
% \newblock \url{http://www.secdev.org/projects/scapy/}

% \bibitem{hachoir}
% V.~{S}tinner.
% \newblock {H}achoir, 2009-2012.
% \newblock \url{https://bitbucket.org/haypo/hachoir/wiki/Home}

% \end{thebibliography}


\appendix
\section{Annexe: grammaire des extensions}


\subsection{Options}

\shorthandoff{:}
\begin{tabbing}
  \textit{option} ::\= = \= \textbf{\tt with\_lwt} \\
  \> $\vert$ \> \textbf{\tt with\_exact}\footnotemark \\
  \> $\vert$ \> \textbf{\tt top}\addtocounter{footnote}{-1}\footnotemark \\
  \> $\vert$ \> \textbf{\tt param} \textit{expression}\addtocounter{footnote}{-1}\footnotemark \\
  \> $\vert$ \> \textbf{\tt enrich}\footnotemark \\
  \> $\vert$ \> \textbf{\tt exhaustive}\addtocounter{footnote}{-1}\footnotemark
\end{tabbing}
\shorthandon{:}
\addtocounter{footnote}{-1}\footnotetext{Ces options n'ont de sens
  que pour les structures, les unions et les alias.}
\addtocounter{footnote}{1}\footnotetext{Ces options n'ont de sens
  que pour les unions.}


\subsection{\FAceSLTypes}

\shorthandoff{:}
\begin{tabbing}
  \textit{\FAceSLType} ::\= = \= \textbf{\tt char} \\
  \> $\vert$ \> \textbf{\tt uintN} \\
  \> $\vert$ \> \textbf{\tt ipv4} \\
  \> $\vert$ \> \textbf{\tt ipv6} \\
  \> $\vert$ \> \textbf{\tt string} \\
  \> $\vert$ \> \textbf{\tt string} (\textit{expression}) \\
  \> $\vert$ \> \textbf{\tt string} [\textit{type entier}] \\
  \> $\vert$ \> \textbf{\tt binstring} \\
  \> $\vert$ \> \textbf{\tt binstring} (\textit{expression}) \\
  \> $\vert$ \> \textbf{\tt binstring} [\textit{type entier}] \\
  \> $\vert$ \> \textbf{\tt list} \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textit{type personnalisé} \\
  \> $\vert$ \> \textit{type personnalisé} (\textit{paramètres})
\end{tabbing}


\subsection{Énumérations}

\shorthandoff{:}
\begin{tabbing}
  \textit{énumération} ::= \textbf{\tt enum} \= \textit{identifiant} (\textit{taille}, \textit{comportement\_enum}, \textit{options}) = \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [, \textit{texte}]\footnotemark\\
  \> ... \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [, \textit{texte}] \\
  \\
  \textit{comportement\_enum} ::\= = \= \textbf{\tt UnknownVal} \textit{Constructor} \\
  \> $\vert$ \> \textbf{\tt Exception} \textit{Exception}
\end{tabbing}
\shorthandon{:}
\footnotetext{Ce texte sera renvoyé par \texttt{string\_of\_enum} pour
  cette valeur de l'énumération.  Si aucun texte n'est donné, le nom
  du constructeur sera utilisé.}


\subsection{Structures, unions et alias}

\shorthandoff{:}
\begin{tabbing}
  \textit{structure} ::= \= \textbf{\tt struct} \= \textit{identifiant} [\textit{struct\_options}] = \{ \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType}; \\
  \> \> ... \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType} \\
  \> \} \\
  \\
  \textit{union} ::= \textbf{\tt union} \= \textit{identifiant} (\textit{comportement\_union}, \textit{union\_options}) = \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \> ... \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \\
  \textit{comportement\_union} ::\= = \= \textit{Constructor} \\
  \> $\vert$ \> \textit{Constructor} \textbf{\tt of} \textit{\FAceSLType} \\
  \\
  \textit{alias} ::= \textbf{\tt alias} \textit{identifiant} = \textit{\FAceSLType}
\end{tabbing}
\shorthandon{:}


\subsection{Description des objets ASN.1}

\shorthandoff{:}
\begin{tabbing}
  \textit{ASN1Header} ::= \textit{ASN1Class} \textbf{\tt *} \textit{ASN1Tag} \\
  \\
  \textit{ASN1Type} ::= \textit{ASN1Header} \texttt{option} \textbf{\tt *}
                        \textit{ASN1TypeContent} \\
  \\
  \textit{ASN1TypeContent} ::\= = \= \textbf{\tt asn1\_bool} \\
  \> $\vert$ \> \textbf{\tt asn1\_integer} \\
  \> $\vert$ \> \textbf{\tt asn1\_bitstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_enumerated} \\
  \> $\vert$ \> \textbf{\tt asn1\_octetstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_null} \\
  \> $\vert$ \> \textbf{\tt asn1\_oid} \\
  \> $\vert$ \> \textbf{\tt asn1\_list} \textbf{\tt of} \textit{ASN1Type} \\
  \> $\vert$ \> \textbf{\tt asn1\_container} \textbf{\tt of} \textit{ASN1Type} \\
  \> $\vert$ \> \textbf{asn1\_anything} \\
  \> $\vert$ \> \textit{custom type} \\
  \> $\vert$ \> \textit{custom type} (\textit{paramètres}) \\
  \\
  \textit{alias\_ASN.1} ::= \textbf{\tt asn1\_alias} \textit{identifiant} = \textit{ASN1Type}
\end{tabbing}
\shorthandon{:}


\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage

\end{document}
